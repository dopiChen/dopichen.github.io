---
layout: post
title: "动态规划"
date: 2024-12-26
collection: xjtuse-project-management
---
当一个问题具有如下特征是可以使用动态规划算法：

• **重叠子问题（Overlapping Subproblems）**：指一个问题在递归求解的过程中，会多次遇到相同的子问题。例如，某些子问题的解会被多次重复计算。

• **最优子结构（Optimal Substructure）**：指一个问题的最优解可以通过其子问题的最优解来构造。这意味着解决问题的过程可以分解成求解子问题，并通过组合子问题的解得到整体问题的解。
**==父问题的最优解一定是两个子问题最优解之和==**

• **递归问题不一定都能用动态规划解决**：动态规划解决的是**有重叠子问题**和**最优子结构**的递归问题。如果递归问题不具备重叠子问题的性质，那么动态规划不适用。

• **可以用动态规划解决的递归问题一定能用递归解决**：动态规划是通过优化递归中的重复计算来实现的，因此所有可以用动态规划解决的问题本质上也可以用递归解决，只不过效率可能较低。

**核心思想**：记表备查：保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。

### 与分治法的区别：

- 相同点：都是把问题分解成子问题进行求解
- 不同点：分治法的所要解决的子问题都是独立的，但是动态规划要解决的子问题是会有重复的，所要要进行记录，减少不必要的计算



### 两种基本形态
#### 动态规划

- 自底向上递归

#### 备忘录法
- 自顶向下递归






例子：

![](/assets/xjtuse-algorithm/2d63f9bff5cebf5685607bfa16429d2d.webp)


#### 1、递归算法

```java
public static int cut(int []p,int n)
	{
		if(n==0)
			return 0;
		int q=Integer.MIN_VALUE;
		for(int i=1;i<=n;i++)
		{
			q=Math.max(q, p[i-1]+cut(p, n-i));	
		}
		return q;
	}

```

需要重复计算子问题的解导致同时需要保存上下文信息，造成栈空间占用很严重

#### 2、备忘录算法

```java
public static int cutMemo(int []p)
	{
		int []r=new int[p.length+1];
		for(int i=0;i<=p.length;i++)
			r[i]=-1;						
		return cut(p, p.length, r);
	}
	public static int cut(int []p,int n,int []r)
	{
		int q=-1;
		if(r[n]>=0)
			return r[n];
		if(n==0)
			q=0;
		else {
			for(int i=1;i<=n;i++)
				q=Math.max(q, cut(p, n-i,r)+p[i-1]);
		}
		r[n]=q;
		
		return q;
	}

```


将算过的子问题的解进行记录，当需要再算该子问题时可以直接进行调用而非重复计算，可以一定程度上减少递归的深度

#### 3、动态规划
**==自底向上==**
直接先算子问题的解然后将子问题的解加起来得到父问题的最优解
```java
public static int buttom_up_cut(int []p)
	{
		int []r=new int[p.length+1];
		for(int i=1;i<=p.length;i++)
		{
			int q=-1;
			//①
			for(int j=1;j<=i;j++)
				q=Math.max(q, p[j-1]+r[i-j]);
			r[i]=q;
		}
		return r[p.length];
	}

```

自底向上的动态规划问题中最重要的是理解注释①处的循环，这里外面的循环是求r[1],r[2]…，里面的循环是求出r[1],r[2]…的最优解，也就是说r[i]中保存的是钢条长度为i时划分的最优解，这里面涉及到了最优子结构问题，也就是一个问题取最优解的时候，它的子问题也一定要取得最优解。