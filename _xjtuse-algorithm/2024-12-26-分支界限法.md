---
layout: post
title: "分支界限法"
date: 2024-12-26
collection: xjtuse-project-management
---


**问题重现**

4皇后问题要求在 的棋盘上放置4个皇后，使得它们互不攻击对方，即任意两个皇后不能在同一行、同一列或同一条斜线上。
  
**1. 解空间结构**

  

解空间采用排列树：

• 每一层代表棋盘的一行。

• 每个节点表示当前行放置一个皇后的位置。

• 树的深度为4（对应棋盘的4行）。

**2. 搜索范围**

解空间范围为所有可能的排列，大小为 $4!=24$。但通过剪枝函数可以有效减少搜索范围。

  

**3. 剪枝函数**

  

剪枝函数排除非法分支，条件包括：

1. **列约束**：检查同一列是否已有皇后。

2. **主对角线约束**：检查是否存在冲突的皇后，主对角线编号为$row-col$ 。

3. **次对角线约束**：检查是否存在冲突的皇后，次对角线编号为 $row+col$。

  

**4. 搜索过程**

• 深度优先搜索（DFS）。

• 每次尝试在当前行放置一个皇后，如果放置成功，递归处理下一行。

• 若放置失败（冲突），回溯到上一行，尝试下一个位置。

  

**解的表示**


用数组 $x=[x_1,x_2,x_3,x_4]$表示解，其中 表示第 行皇后所在的列。

  

**搜索树**

  

以下是4皇后问题的搜索树（其中 ✔ 表示合法解，✘ 表示剪枝）：

  ![](/assets/xjtuse-algorithm/bb96f52f7dc5fc49b3fe31525ea2f8ab.webp)
  

• 起始节点为 []（无皇后）。

• 每一层分支代表尝试将皇后放置在某列。

• 剪枝函数排除了冲突的状态，减少无效搜索。

  

**完整解**

  

两个解分别为：

$$
1.x=[1,3,4,2]
$$

$$
2.x=[2,4,1,3]
$$

  

**Python代码实现**

```python

  
def is_safe(row, col, solution):

    for i in range(row):

        # 检查列冲突、主对角线冲突、次对角线冲突

        if solution[i] == col or abs(solution[i] - col) == abs(i - row):

            return False

    return True

  

def solve_n_queens(n, row=0, solution=[]):

    if row == n:

        print("Solution:", solution)

        return

    for col in range(1, n + 1):  # 列范围是1到n

        if is_safe(row, col, solution):

            solve_n_queens(n, row + 1, solution + [col])

  

```


```
solve_n_queens(4)
```

  

运行结果：

![](/assets/xjtuse-algorithm/e43a48cd9647306065b03b97f4aef783.webp)

  

**总结**
分支限界法利用剪枝函数有效减少搜索范围，使得解空间更为紧凑。4皇后问题的解空间树中剪枝减少了大量无效路径，仅需探索少量节点即可找到所有解。